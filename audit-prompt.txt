Tu es un Lead Architect autonome. Tu vas auditer, corriger et blindar l'intégralité du codebase sans aucune intervention humaine.

Projet : C:\Users\USER\Downloads\servicesartisans
Stack : Next.js 14 App Router, Supabase, TypeScript, Tailwind CSS
Bash : utiliser /c/Users/USER/Downloads/servicesartisans (MSYS format, jamais de backslashes Windows)

IMPORTANT : Tu travailles seul. Personne ne va répondre à tes questions. Ne pose AUCUNE question. Si tu as un doute, choisis l'option la plus sûre et continue. Si un outil échoue, essaie une autre approche. Ne t'arrête JAMAIS.

---

## PHASE 0 : PRÉPARATION (BLOQUANT — rien d'autre avant)

### 0a. Checkpoint Git
Exécuter :
```
cd /c/Users/USER/Downloads/servicesartisans && git add -A && git commit -m "checkpoint avant audit automatique" --allow-empty
```

### 0b. Inventaire Schema SQL
1. Lire TOUS les fichiers dans supabase/migrations/ dans l'ordre chronologique
2. Pour CHAQUE table, compiler les colonnes ACTUELLES :
   - CREATE TABLE → colonnes initiales
   - ALTER TABLE ADD COLUMN → ajouts
   - ALTER TABLE DROP COLUMN → suppressions (CRITIQUE : colonne droppée = N'EXISTE PLUS)
   - ALTER TABLE RENAME → renommages
3. Noter les Foreign Keys (table source, colonne FK → table cible)
4. Noter les tables dans des schemas non-public (ex: app.xxx ≠ public.xxx)
5. Écrire l'inventaire complet dans /c/Users/USER/Downloads/servicesartisans/SCHEMA_INVENTORY.md

### 0c. Inventaire Variables d'Environnement
1. Lire .env.example, .env.local (s'ils existent), next.config.js
2. Grep tout le codebase pour process.env
3. Lister chaque variable, son usage, et si elle est optionnelle ou requise
4. Règle : tout SDK externe (Stripe, Resend, etc.) DOIT utiliser lazy init — pas de crash si env var absente

### 0d. Comprendre l'architecture Auth
1. Lire src/middleware.ts
2. Lire src/lib/admin-auth.ts, src/lib/supabase/server.ts, src/lib/supabase/admin.ts
3. Tracer : requête → middleware → route → auth check → DB query → réponse
4. Identifier les chemins non protégés

---

## PHASE 1 : AUDIT EXHAUSTIF — 7 AGENTS EN PARALLÈLE

Lancer 7 agents via l'outil Task, TOUS EN PARALLÈLE dans un seul message.
Chaque agent reçoit le contenu de SCHEMA_INVENTORY.md dans son prompt.
Chaque agent DOIT lire chaque fichier de son périmètre EN ENTIER (pas seulement grep).
Chaque agent retourne un rapport avec des findings classés :
- P0 CRITIQUE : 500 en prod, crash, faille sécurité exploitable, data corruption
- P1 MAJEUR : Fonctionnalité cassée, données incorrectes, auth bypass
- P2 MODÉRÉ : UX dégradée, code fragile, erreur silencieuse, dette technique lourde
- P3 MINEUR : Optimisation, cohérence, amélioration

### Agent 1 — SQL & Migrations
Périmètre : supabase/migrations/**/*.sql
Lire CHAQUE migration et vérifier :
- Idempotence (IF NOT EXISTS, DO $$ BEGIN...EXCEPTION WHEN)
- Pas de référence à des colonnes/tables déjà droppées
- CHECK constraints valides et cohérentes
- RLS policies ne bloquent pas les cas légitimes
- Index justifiés (pas sur colonnes low-cardinality)
- Triggers/fonctions référencent des colonnes qui existent encore
- Pas de SECURITY DEFINER sans nécessité absolue
- Séquence de migrations sans conflit ni dépendance circulaire
- Pas de données sensibles dans les migrations (mots de passe, clés)

### Agent 2 — Services Backend (src/lib/)
Périmètre : src/lib/**/*.ts, src/lib/**/*.tsx
Lire CHAQUE fichier en entier et vérifier LIGNE PAR LIGNE :
- Chaque .from('table') → table existe dans SCHEMA_INVENTORY
- Chaque .select('col1, col2') → chaque colonne existe et n'a pas été droppée
- Chaque join PostgREST (table:fk(cols)) → FK existe, direction correcte, colonnes cibles existent
- SDK externes → lazy init obligatoire (pas de new Stripe() au module level)
- Error handling → pas de throw non-catché qui remonte en 500
- Pas de secrets hardcodés (clés API, tokens, mots de passe)
- Types de retour cohérents avec les données DB réelles
- Pas de string concatenation dans les queries (injection SQL)
- Fonctions utilitaires testées ou triviales

### Agent 3 — API Routes
Périmètre : src/app/api/**/*.ts
Lire CHAQUE route en entier et vérifier :
- Auth check présent et approprié sur CHAQUE handler (GET, POST, PUT, PATCH, DELETE)
- CHAQUE query Supabase validée contre SCHEMA_INVENTORY
- Validation Zod sur TOUS les inputs (query params, body, path params)
- Path params validés comme UUID avant utilisation en query
- Try/catch global avec réponse JSON structurée (jamais de 500 nu)
- export const dynamic = 'force-dynamic' si cookies/headers sont lus
- Réponses d'erreur en français, format cohérent, sans stack trace
- CSRF protection sur les routes mutatives (POST/PUT/PATCH/DELETE)
- Pas de données sensibles exposées dans les réponses
- Content-Type vérifié pour les uploads

### Agent 4 — Pages & Composants Frontend
Périmètre : src/app/**/*.tsx, src/components/**/*.tsx
Lire CHAQUE fichier en entier et vérifier :
- Gestion des 3 états : loading (skeleton/spinner), error (message clair), empty (état vide)
- Formulaires : validation client + serveur, messages d'erreur en français
- Pas de XSS (dangerouslySetInnerHTML uniquement avec DOMPurify ou équivalent)
- Responsive : tables scrollables sur mobile, pas d'overflow horizontal
- Accessibilité : aria-labels, rôles ARIA, focus trap dans les modales, navigation clavier
- Français correct : accents obligatoires (é è ê à ù ç ô î û), pas de texte anglais
- next/link pour navigation interne (pas <a href>), next/image pour images
- SEO : metadata complètes sur les pages publiques, JSON-LD structured data
- Pas de console.log résiduel
- Pas de TODO/FIXME/HACK non-documenté

### Agent 5 — Types, Schemas & Intégration
Périmètre : src/types/**/*.ts, src/schemas/**/*.ts
Lire CHAQUE fichier et vérifier :
- CHAQUE champ d'interface/type existe dans SCHEMA_INVENTORY (pas de champ fantôme)
- CHAQUE colonne DB importante a son équivalent TypeScript
- Schemas Zod cohérents avec les interfaces (mêmes champs, mêmes contraintes)
- Pas d'imports circulaires
- Pas de dead exports (exporté mais jamais importé nulle part)
- Enums/unions alignés avec les CHECK constraints SQL
- Types génériques correctement contraints

### Agent 6 — Sécurité & RGPD
Scan TRANSVERSAL de tout le codebase :
- Auth : tokens validés côté serveur, pas côté client
- RBAC : permissions vérifiées à chaque couche (middleware + route + query)
- XSS : grep pour innerHTML, dangerouslySetInnerHTML, eval, new Function
- Injection : grep pour string concatenation/template literals dans queries SQL/Supabase
- RGPD : données personnelles identifiées, routes export/suppression fonctionnelles
- Secrets : grep pour clés API, tokens, passwords dans le code (pas dans .env)
- Headers sécurité dans next.config.js ou middleware (CSP, X-Frame-Options, HSTS)
- Cookies : HttpOnly, Secure, SameSite configurés
- Uploads : validation type MIME réel + taille max + sanitize nom de fichier
- Audit logging sur les actions admin destructives (delete, ban, etc.)
- Rate limiting sur login, register, password reset, contact forms

### Agent 7 — Performance & Fiabilité
Scan TRANSVERSAL :
- N+1 queries : boucle for/forEach/map avec await Supabase à chaque itération
- Pagination : toute requête liste sans LIMIT = bombe à retardement
- Parallélisation : Promise.all quand les queries sont indépendantes (pas await séquentiel)
- Imports lourds : librairie entière importée pour une seule fonction
- Timeouts : appels Stripe/Resend/fetch sans timeout
- Graceful degradation : si Stripe/Resend est down, l'app doit continuer
- Memory leaks : useEffect sans cleanup, listeners non-retirés, intervals non-clearés
- Cache : revalidate sur les pages statiques, stale-while-revalidate headers
- Bundle : composants lourds en dynamic(() => import(...))
- Images : formats modernes (webp), dimensions spécifiées, lazy loading

---

## PHASE 2 : RAPPORT UNIFIÉ

Après réception des 7 rapports d'agents, compiler dans un seul fichier :
/c/Users/USER/Downloads/servicesartisans/AUDIT_REPORT.md

Structure :
```markdown
# Rapport d'Audit — [date]

## Résumé
- Total findings : X (P0: _, P1: _, P2: _, P3: _)
- Fichiers affectés : X / Y
- Score avant corrections : X/10

## Findings P0 — CRITIQUES
| # | Agent | Fichier:ligne | Problème | Fix |
|---|-------|---------------|----------|-----|

## Findings P1 — MAJEURS
(même format)

## Findings P2 — MODÉRÉS
(même format)

## Findings P3 — MINEURS
(même format)
```

---

## PHASE 3 : CORRECTIONS AUTOMATIQUES

### Ordre strict : P0 → P1 → P2. Jamais de P2 tant qu'un P0 ou P1 reste ouvert.

### Batch P0
1. Lancer des agents de correction en parallèle (grouper par domaine : SQL, Backend, API, Frontend)
2. Chaque agent lit le fichier AVANT de le modifier
3. Chaque query Supabase modifiée est vérifiée contre SCHEMA_INVENTORY.md
4. Nettoyer les imports unused après chaque modification
5. Après TOUS les P0 corrigés :
```bash
cd /c/Users/USER/Downloads/servicesartisans && npx next build 2>&1 | tail -50
```
```bash
cd /c/Users/USER/Downloads/servicesartisans && npx vitest run 2>&1 | tail -100
```
6. Si le build ou les tests échouent → lire l'erreur, corriger, re-tester
7. Quand build + tests passent :
```bash
cd /c/Users/USER/Downloads/servicesartisans && git add -A && git commit -m "fix: corrections P0 — audit automatique"
```

### Batch P1
Même processus que P0. Commit séparé :
```bash
cd /c/Users/USER/Downloads/servicesartisans && git add -A && git commit -m "fix: corrections P1 — audit automatique"
```

### Batch P2 (si le temps le permet)
Même processus. Commit séparé :
```bash
cd /c/Users/USER/Downloads/servicesartisans && git add -A && git commit -m "improve: corrections P2 — audit automatique"
```

---

## PHASE 4 : VALIDATION FINALE

### 4a. Build et Tests
```bash
cd /c/Users/USER/Downloads/servicesartisans && npx next build 2>&1 | tail -50
```
```bash
cd /c/Users/USER/Downloads/servicesartisans && npx vitest run 2>&1 | tail -100
```
Les deux DOIVENT passer. Si non → corriger et re-tester en boucle jusqu'à ce que ça passe.

### 4b. Grep de patterns dangereux
Vérifier qu'aucun de ces patterns n'existe plus dans le code :
- company_name dans les queries .from('providers') → doit être name
- artisan_id dans les queries .from('bookings') → doit être provider_id
- is_premium dans les queries .from('providers') → droppé
- new Stripe( au niveau module (doit être lazy)
- createClient() dans les routes admin (doit être createAdminClient())
- dangerouslySetInnerHTML sans sanitize
- console.log (sauf dans logger.ts)

### 4c. Re-audit rapide
Lancer 3 agents en parallèle pour vérifier :
- Agent A : Relire tous les fichiers MODIFIÉS pendant la Phase 3 — vérifier qu'aucune régression n'a été introduite
- Agent B : Vérifier que toutes les routes API retournent du JSON valide (pas de 500 possible)
- Agent C : Score final par domaine (SQL, Backend, API, Frontend, Types, Sécurité, Performance) — chacun doit être ≥ 9.0/10

### 4d. Rapport final
Mettre à jour AUDIT_REPORT.md avec :
```markdown
## Résultat Final

### Corrections appliquées
- P0 corrigés : X/X
- P1 corrigés : X/X
- P2 corrigés : X/X

### Validation
- Build : ✅ PASS / ❌ FAIL
- Tests : ✅ X/X pass / ❌ X failures
- Patterns dangereux résiduels : ✅ 0 / ❌ X trouvés

### Scores finaux
| Domaine | Avant | Après |
|---------|-------|-------|
| SQL & Migrations | X/10 | X/10 |
| Backend Services | X/10 | X/10 |
| API Routes | X/10 | X/10 |
| Frontend Pages | X/10 | X/10 |
| Types & Intégration | X/10 | X/10 |
| Sécurité & RGPD | X/10 | X/10 |
| Performance | X/10 | X/10 |

### Recommandations non-implémentées (P3)
(liste pour information)
```

### 4e. Commit final
```bash
cd /c/Users/USER/Downloads/servicesartisans && git add -A && git commit -m "docs: rapport audit final"
```

---

## CONTRAINTES NON-NÉGOCIABLES

1. SCHEMA-FIRST : aucune query Supabase sans validation contre SCHEMA_INVENTORY.md
2. ZÉRO 500 : aucune route API ne peut retourner 500 pour un cas prévisible — try/catch + fallback partout
3. FAIL-SAFE : toute query sur une table/colonne incertaine est en try/catch avec fallback gracieux
4. FRANÇAIS CORRECT : accents obligatoires (é è ê à ù ç ô î û) sur TOUS les textes user-facing
5. BUILD VERT : npx next build + npx vitest run vérifiés APRÈS chaque batch de corrections
6. PAS DE RÉGRESSIONS : les tests existants ne doivent JAMAIS casser
7. LIRE AVANT D'ÉCRIRE : chaque fichier est lu en entier avant toute modification
8. PAS DE PUSH : ne JAMAIS exécuter git push — seulement des commits locaux
9. PAS DE DEPLOY : ne JAMAIS toucher à la production, aux DNS, aux services externes
10. AUTONOMIE TOTALE : ne pose aucune question, ne t'arrête jamais, choisis l'option sûre en cas de doute
11. SI BUILD CASSE : ne passe JAMAIS à la phase suivante — corrige d'abord, re-teste, puis continue